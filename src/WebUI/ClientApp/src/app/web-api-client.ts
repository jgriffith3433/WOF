//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICalledIngredientsClient {
    getCalledIngredients(): Observable<GetCalledIngredientsVm>;
    create(command: CreateCalledIngredientCommand): Observable<number>;
    getCalledIngredientDetails(id: number): Observable<CalledIngredientDetailsVm>;
    searchProductStockName(id: number | undefined, search: string | null | undefined): Observable<CalledIngredientDetailsVm>;
    update(id: number, command: UpdateCalledIngredientCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateCalledIngredientDetails(id: number | undefined, command: UpdateCalledIngredientDetailsCommand): Observable<CalledIngredientDetailsVm>;
}

@Injectable({
    providedIn: 'root'
})
export class CalledIngredientsClient implements ICalledIngredientsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCalledIngredients(): Observable<GetCalledIngredientsVm> {
        let url_ = this.baseUrl + "/api/CalledIngredients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalledIngredients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalledIngredients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCalledIngredientsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCalledIngredientsVm>;
        }));
    }

    protected processGetCalledIngredients(response: HttpResponseBase): Observable<GetCalledIngredientsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCalledIngredientsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCalledIngredientCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CalledIngredients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCalledIngredientDetails(id: number): Observable<CalledIngredientDetailsVm> {
        let url_ = this.baseUrl + "/api/CalledIngredients/GetCalledIngredientDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalledIngredientDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalledIngredientDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CalledIngredientDetailsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CalledIngredientDetailsVm>;
        }));
    }

    protected processGetCalledIngredientDetails(response: HttpResponseBase): Observable<CalledIngredientDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalledIngredientDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchProductStockName(id: number | undefined, search: string | null | undefined): Observable<CalledIngredientDetailsVm> {
        let url_ = this.baseUrl + "/api/CalledIngredients/SearchProductStockName?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchProductStockName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchProductStockName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CalledIngredientDetailsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CalledIngredientDetailsVm>;
        }));
    }

    protected processSearchProductStockName(response: HttpResponseBase): Observable<CalledIngredientDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalledIngredientDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCalledIngredientCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CalledIngredients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CalledIngredients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCalledIngredientDetails(id: number | undefined, command: UpdateCalledIngredientDetailsCommand): Observable<CalledIngredientDetailsVm> {
        let url_ = this.baseUrl + "/api/CalledIngredients/UpdateCalledIngredientDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCalledIngredientDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCalledIngredientDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CalledIngredientDetailsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CalledIngredientDetailsVm>;
        }));
    }

    protected processUpdateCalledIngredientDetails(response: HttpResponseBase): Observable<CalledIngredientDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalledIngredientDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IChatClient {
    create(query: GetChatResponseQuery): Observable<GetChatResponseVm>;
    speech(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<GetChatTextFromSpeechVm>;
}

@Injectable({
    providedIn: 'root'
})
export class ChatClient implements IChatClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(query: GetChatResponseQuery): Observable<GetChatResponseVm> {
        let url_ = this.baseUrl + "/api/Chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetChatResponseVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetChatResponseVm>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GetChatResponseVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetChatResponseVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    speech(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: IHeaderDictionary | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<GetChatTextFromSpeechVm> {
        let url_ = this.baseUrl + "/api/Chat/speech";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpeech(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpeech(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetChatTextFromSpeechVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetChatTextFromSpeechVm>;
        }));
    }

    protected processSpeech(response: HttpResponseBase): Observable<GetChatTextFromSpeechVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetChatTextFromSpeechVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICompletedOrdersClient {
    get(): Observable<CompletedOrdersVm>;
    create(command: CreateCompletedOrderCommand): Observable<number>;
    get2(id: number): Observable<CompletedOrderDto>;
    update(id: number, command: UpdateCompletedOrderCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getCompletedOrderProduct(id: number): Observable<CompletedOrderProductDto>;
    searchCompletedOrderProductName(id: number | undefined, search: string | null | undefined): Observable<CompletedOrderProductDto>;
    createCompletedOrderProduct(command: CreateCompletedOrderProductCommand): Observable<number>;
    updateCompletedOrderProduct(id: number, command: UpdateCompletedOrderProductCommand): Observable<CompletedOrderProductDto>;
    deleteCompletedOrderProduct(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CompletedOrdersClient implements ICompletedOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<CompletedOrdersVm> {
        let url_ = this.baseUrl + "/api/CompletedOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompletedOrdersVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompletedOrdersVm>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompletedOrdersVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompletedOrdersVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCompletedOrderCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CompletedOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get2(id: number): Observable<CompletedOrderDto> {
        let url_ = this.baseUrl + "/api/CompletedOrders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompletedOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompletedOrderDto>;
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<CompletedOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompletedOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCompletedOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CompletedOrders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CompletedOrders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCompletedOrderProduct(id: number): Observable<CompletedOrderProductDto> {
        let url_ = this.baseUrl + "/api/CompletedOrders/GetCompletedOrderProduct/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompletedOrderProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompletedOrderProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompletedOrderProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompletedOrderProductDto>;
        }));
    }

    protected processGetCompletedOrderProduct(response: HttpResponseBase): Observable<CompletedOrderProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompletedOrderProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchCompletedOrderProductName(id: number | undefined, search: string | null | undefined): Observable<CompletedOrderProductDto> {
        let url_ = this.baseUrl + "/api/CompletedOrders/SearchCompletedOrderProductName?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCompletedOrderProductName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCompletedOrderProductName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompletedOrderProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompletedOrderProductDto>;
        }));
    }

    protected processSearchCompletedOrderProductName(response: HttpResponseBase): Observable<CompletedOrderProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompletedOrderProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCompletedOrderProduct(command: CreateCompletedOrderProductCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CompletedOrders/CreateCompletedOrderProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCompletedOrderProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCompletedOrderProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateCompletedOrderProduct(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCompletedOrderProduct(id: number, command: UpdateCompletedOrderProductCommand): Observable<CompletedOrderProductDto> {
        let url_ = this.baseUrl + "/api/CompletedOrders/UpdateCompletedOrderProduct/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompletedOrderProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompletedOrderProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompletedOrderProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompletedOrderProductDto>;
        }));
    }

    protected processUpdateCompletedOrderProduct(response: HttpResponseBase): Observable<CompletedOrderProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompletedOrderProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCompletedOrderProduct(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CompletedOrders/DeleteCompletedOrderProduct/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompletedOrderProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompletedOrderProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCompletedOrderProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICookedRecipeCalledIngredientsClient {
    getCookedRecipeCalledIngredientDetails(id: number): Observable<CookedRecipeCalledIngredientDetailsVm>;
    searchProductStockName(id: number | undefined, search: string | null | undefined): Observable<CookedRecipeCalledIngredientDetailsVm>;
    create(command: CreateCookedRecipeCalledIngredientCommand): Observable<number>;
    update(id: number, command: UpdateCookedRecipeCalledIngredientCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateCookedRecipeCalledIngredientDetails(id: number | undefined, command: UpdateCookedRecipeCalledIngredientDetailsCommand): Observable<CookedRecipeCalledIngredientDetailsVm>;
}

@Injectable({
    providedIn: 'root'
})
export class CookedRecipeCalledIngredientsClient implements ICookedRecipeCalledIngredientsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCookedRecipeCalledIngredientDetails(id: number): Observable<CookedRecipeCalledIngredientDetailsVm> {
        let url_ = this.baseUrl + "/api/CookedRecipeCalledIngredients/GetCookedRecipeCalledIngredientDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCookedRecipeCalledIngredientDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCookedRecipeCalledIngredientDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookedRecipeCalledIngredientDetailsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookedRecipeCalledIngredientDetailsVm>;
        }));
    }

    protected processGetCookedRecipeCalledIngredientDetails(response: HttpResponseBase): Observable<CookedRecipeCalledIngredientDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookedRecipeCalledIngredientDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchProductStockName(id: number | undefined, search: string | null | undefined): Observable<CookedRecipeCalledIngredientDetailsVm> {
        let url_ = this.baseUrl + "/api/CookedRecipeCalledIngredients/SearchProductStockName?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchProductStockName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchProductStockName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookedRecipeCalledIngredientDetailsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookedRecipeCalledIngredientDetailsVm>;
        }));
    }

    protected processSearchProductStockName(response: HttpResponseBase): Observable<CookedRecipeCalledIngredientDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookedRecipeCalledIngredientDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCookedRecipeCalledIngredientCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CookedRecipeCalledIngredients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCookedRecipeCalledIngredientCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CookedRecipeCalledIngredients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CookedRecipeCalledIngredients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCookedRecipeCalledIngredientDetails(id: number | undefined, command: UpdateCookedRecipeCalledIngredientDetailsCommand): Observable<CookedRecipeCalledIngredientDetailsVm> {
        let url_ = this.baseUrl + "/api/CookedRecipeCalledIngredients/UpdateCookedRecipeCalledIngredientDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCookedRecipeCalledIngredientDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCookedRecipeCalledIngredientDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookedRecipeCalledIngredientDetailsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookedRecipeCalledIngredientDetailsVm>;
        }));
    }

    protected processUpdateCookedRecipeCalledIngredientDetails(response: HttpResponseBase): Observable<CookedRecipeCalledIngredientDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookedRecipeCalledIngredientDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICookedRecipesClient {
    get(): Observable<CookedRecipesVm>;
    create(command: CreateCookedRecipeCommand): Observable<CookedRecipeDto>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CookedRecipesClient implements ICookedRecipesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<CookedRecipesVm> {
        let url_ = this.baseUrl + "/api/CookedRecipes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookedRecipesVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookedRecipesVm>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CookedRecipesVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookedRecipesVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCookedRecipeCommand): Observable<CookedRecipeDto> {
        let url_ = this.baseUrl + "/api/CookedRecipes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CookedRecipeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CookedRecipeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CookedRecipeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CookedRecipeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CookedRecipes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductsClient {
    getProducts(): Observable<GetProductsVm>;
    create(command: CreateProductCommand): Observable<ProductDto>;
    update(id: number | undefined, command: UpdateProductCommand): Observable<ProductDto>;
    updateName(id: number, command: UpdateProductNameCommand): Observable<ProductDto>;
    updateUnitType(id: number, command: UpdateProductUnitTypeCommand): Observable<ProductDto>;
    updateSize(id: number, command: UpdateProductSizeCommand): Observable<ProductDto>;
    getProductDetails(id: number | undefined): Observable<ProductDto>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient implements IProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProducts(): Observable<GetProductsVm> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductsVm>;
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<GetProductsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductCommand): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number | undefined, command: UpdateProductCommand): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateName(id: number, command: UpdateProductNameCommand): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/UpdateProductName/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processUpdateName(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUnitType(id: number, command: UpdateProductUnitTypeCommand): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/UpdateUnitType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUnitType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUnitType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processUpdateUnitType(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSize(id: number, command: UpdateProductSizeCommand): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/UpdateSize/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processUpdateSize(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductDetails(id: number | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/GetProductDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto>;
        }));
    }

    protected processGetProductDetails(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProductStockClient {
    getProductStocks(): Observable<GetProductStocksVm>;
    update(id: number | undefined, command: UpdateProductStockCommand): Observable<ProductStockDto>;
    create(command: CreateProductStockCommand): Observable<number>;
    getProductStockDetails(id: number | undefined, search: string | null | undefined): Observable<ProductStockDetailsVm>;
    updateProductStockDetails(id: number | undefined, command: UpdateProductStockDetailsCommand): Observable<ProductStockDto>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductStockClient implements IProductStockClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProductStocks(): Observable<GetProductStocksVm> {
        let url_ = this.baseUrl + "/api/ProductStock";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductStocks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductStocks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductStocksVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductStocksVm>;
        }));
    }

    protected processGetProductStocks(response: HttpResponseBase): Observable<GetProductStocksVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductStocksVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number | undefined, command: UpdateProductStockCommand): Observable<ProductStockDto> {
        let url_ = this.baseUrl + "/api/ProductStock?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStockDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProductStockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductStockCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ProductStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductStockDetails(id: number | undefined, search: string | null | undefined): Observable<ProductStockDetailsVm> {
        let url_ = this.baseUrl + "/api/ProductStock/GetProductStockDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductStockDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductStockDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStockDetailsVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStockDetailsVm>;
        }));
    }

    protected processGetProductStockDetails(response: HttpResponseBase): Observable<ProductStockDetailsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateProductStockDetails(id: number | undefined, command: UpdateProductStockDetailsCommand): Observable<ProductStockDto> {
        let url_ = this.baseUrl + "/api/ProductStock/UpdateProductStockDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductStockDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductStockDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductStockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductStockDto>;
        }));
    }

    protected processUpdateProductStockDetails(response: HttpResponseBase): Observable<ProductStockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductStock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRecipesClient {
    get(): Observable<RecipesVm>;
    create(command: CreateRecipeCommand): Observable<RecipeDto>;
    updateName(id: number, command: UpdateRecipeNameCommand): Observable<RecipeDto>;
    updateServes(id: number, command: UpdateRecipeServesCommand): Observable<RecipeDto>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RecipesClient implements IRecipesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<RecipesVm> {
        let url_ = this.baseUrl + "/api/Recipes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipesVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipesVm>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RecipesVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipesVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateRecipeCommand): Observable<RecipeDto> {
        let url_ = this.baseUrl + "/api/Recipes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RecipeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateName(id: number, command: UpdateRecipeNameCommand): Observable<RecipeDto> {
        let url_ = this.baseUrl + "/api/Recipes/UpdateName/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipeDto>;
        }));
    }

    protected processUpdateName(response: HttpResponseBase): Observable<RecipeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateServes(id: number, command: UpdateRecipeServesCommand): Observable<RecipeDto> {
        let url_ = this.baseUrl + "/api/Recipes/UpdateServes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateServes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateServes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipeDto>;
        }));
    }

    protected processUpdateServes(response: HttpResponseBase): Observable<RecipeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Recipes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITodoItemsClient {
    getTodoItemsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTodoItemBriefDto>;
    create(command: CreateTodoItemCommand): Observable<number>;
    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTodoItemsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTodoItemBriefDto> {
        let url_ = this.baseUrl + "/api/TodoItems?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTodoItemsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTodoItemsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTodoItemBriefDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTodoItemBriefDto>;
        }));
    }

    protected processGetTodoItemsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTodoItemBriefDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITodoListsClient {
    get(): Observable<TodosVm>;
    create(command: CreateTodoListCommand): Observable<number>;
    get2(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TodosVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TodosVm>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get2(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class GetCalledIngredientsVm implements IGetCalledIngredientsVm {
    calledIngredients?: CalledIngredientDto[];

    constructor(data?: IGetCalledIngredientsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["calledIngredients"])) {
                this.calledIngredients = [] as any;
                for (let item of _data["calledIngredients"])
                    this.calledIngredients!.push(CalledIngredientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCalledIngredientsVm {
        data = typeof data === 'object' ? data : {};
        let result = new GetCalledIngredientsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.calledIngredients)) {
            data["calledIngredients"] = [];
            for (let item of this.calledIngredients)
                data["calledIngredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetCalledIngredientsVm {
    calledIngredients?: CalledIngredientDto[];
}

export class CalledIngredientDto implements ICalledIngredientDto {
    id?: number;
    name?: string;
    productStock?: ProductStock;
    units?: number;
    unitType?: number;

    constructor(data?: ICalledIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.productStock = _data["productStock"] ? ProductStock.fromJS(_data["productStock"]) : <any>undefined;
            this.units = _data["units"];
            this.unitType = _data["unitType"];
        }
    }

    static fromJS(data: any): CalledIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalledIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["productStock"] = this.productStock ? this.productStock.toJSON() : <any>undefined;
        data["units"] = this.units;
        data["unitType"] = this.unitType;
        return data;
    }
}

export interface ICalledIngredientDto {
    id?: number;
    name?: string;
    productStock?: ProductStock;
    units?: number;
    unitType?: number;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class ProductStock extends BaseAuditableEntity implements IProductStock {
    name?: string;
    units?: number;
    productId?: number | undefined;
    product?: Product | undefined;

    constructor(data?: IProductStock) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.units = _data["units"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ProductStock {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStock();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["units"] = this.units;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProductStock extends IBaseAuditableEntity {
    name?: string;
    units?: number;
    productId?: number | undefined;
    product?: Product | undefined;
}

export class Product extends BaseAuditableEntity implements IProduct {
    name?: string;
    walmartId?: number | undefined;
    walmartLink?: string | undefined;
    walmartSize?: string | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    error?: string | undefined;
    size?: number;
    price?: number;
    verified?: boolean;
    unitType?: UnitType;
    completedOrderProducts?: CompletedOrderProduct[];
    productStock?: ProductStock;

    constructor(data?: IProduct) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.walmartId = _data["walmartId"];
            this.walmartLink = _data["walmartLink"];
            this.walmartSize = _data["walmartSize"];
            this.walmartItemResponse = _data["walmartItemResponse"];
            this.walmartSearchResponse = _data["walmartSearchResponse"];
            this.error = _data["error"];
            this.size = _data["size"];
            this.price = _data["price"];
            this.verified = _data["verified"];
            this.unitType = _data["unitType"];
            if (Array.isArray(_data["completedOrderProducts"])) {
                this.completedOrderProducts = [] as any;
                for (let item of _data["completedOrderProducts"])
                    this.completedOrderProducts!.push(CompletedOrderProduct.fromJS(item));
            }
            this.productStock = _data["productStock"] ? ProductStock.fromJS(_data["productStock"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["walmartId"] = this.walmartId;
        data["walmartLink"] = this.walmartLink;
        data["walmartSize"] = this.walmartSize;
        data["walmartItemResponse"] = this.walmartItemResponse;
        data["walmartSearchResponse"] = this.walmartSearchResponse;
        data["error"] = this.error;
        data["size"] = this.size;
        data["price"] = this.price;
        data["verified"] = this.verified;
        data["unitType"] = this.unitType;
        if (Array.isArray(this.completedOrderProducts)) {
            data["completedOrderProducts"] = [];
            for (let item of this.completedOrderProducts)
                data["completedOrderProducts"].push(item.toJSON());
        }
        data["productStock"] = this.productStock ? this.productStock.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProduct extends IBaseAuditableEntity {
    name?: string;
    walmartId?: number | undefined;
    walmartLink?: string | undefined;
    walmartSize?: string | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    error?: string | undefined;
    size?: number;
    price?: number;
    verified?: boolean;
    unitType?: UnitType;
    completedOrderProducts?: CompletedOrderProduct[];
    productStock?: ProductStock;
}

export enum UnitType {
    None = 0,
    Bulk = 1,
    Ounce = 2,
    Teaspoon = 3,
    Tablespoon = 4,
    Pound = 5,
    Cup = 6,
    Cloves = 7,
    Can = 8,
    Whole = 9,
    Package = 10,
    Bar = 11,
    Bun = 12,
}

export class CompletedOrderProduct extends BaseAuditableEntity implements ICompletedOrderProduct {
    name?: string;
    walmartId?: number | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    walmartError?: string | undefined;
    completedOrder?: CompletedOrder;
    product?: Product | undefined;

    constructor(data?: ICompletedOrderProduct) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.walmartId = _data["walmartId"];
            this.walmartItemResponse = _data["walmartItemResponse"];
            this.walmartSearchResponse = _data["walmartSearchResponse"];
            this.walmartError = _data["walmartError"];
            this.completedOrder = _data["completedOrder"] ? CompletedOrder.fromJS(_data["completedOrder"]) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): CompletedOrderProduct {
        data = typeof data === 'object' ? data : {};
        let result = new CompletedOrderProduct();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["walmartId"] = this.walmartId;
        data["walmartItemResponse"] = this.walmartItemResponse;
        data["walmartSearchResponse"] = this.walmartSearchResponse;
        data["walmartError"] = this.walmartError;
        data["completedOrder"] = this.completedOrder ? this.completedOrder.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICompletedOrderProduct extends IBaseAuditableEntity {
    name?: string;
    walmartId?: number | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    walmartError?: string | undefined;
    completedOrder?: CompletedOrder;
    product?: Product | undefined;
}

export class CompletedOrder extends BaseAuditableEntity implements ICompletedOrder {
    name?: string;
    userImport?: string | undefined;
    completedOrderProducts?: CompletedOrderProduct[];

    constructor(data?: ICompletedOrder) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.userImport = _data["userImport"];
            if (Array.isArray(_data["completedOrderProducts"])) {
                this.completedOrderProducts = [] as any;
                for (let item of _data["completedOrderProducts"])
                    this.completedOrderProducts!.push(CompletedOrderProduct.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): CompletedOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CompletedOrder();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["userImport"] = this.userImport;
        if (Array.isArray(this.completedOrderProducts)) {
            data["completedOrderProducts"] = [];
            for (let item of this.completedOrderProducts)
                data["completedOrderProducts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICompletedOrder extends IBaseAuditableEntity {
    name?: string;
    userImport?: string | undefined;
    completedOrderProducts?: CompletedOrderProduct[];
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class CalledIngredientDetailsVm implements ICalledIngredientDetailsVm {
    id?: number;
    name?: string;
    productStock?: ProductStock;
    units?: number | undefined;
    unitType?: number;
    productStockId?: number;
    productStockSearchItems?: ProductStock[];

    constructor(data?: ICalledIngredientDetailsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.productStock = _data["productStock"] ? ProductStock.fromJS(_data["productStock"]) : <any>undefined;
            this.units = _data["units"];
            this.unitType = _data["unitType"];
            this.productStockId = _data["productStockId"];
            if (Array.isArray(_data["productStockSearchItems"])) {
                this.productStockSearchItems = [] as any;
                for (let item of _data["productStockSearchItems"])
                    this.productStockSearchItems!.push(ProductStock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalledIngredientDetailsVm {
        data = typeof data === 'object' ? data : {};
        let result = new CalledIngredientDetailsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["productStock"] = this.productStock ? this.productStock.toJSON() : <any>undefined;
        data["units"] = this.units;
        data["unitType"] = this.unitType;
        data["productStockId"] = this.productStockId;
        if (Array.isArray(this.productStockSearchItems)) {
            data["productStockSearchItems"] = [];
            for (let item of this.productStockSearchItems)
                data["productStockSearchItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICalledIngredientDetailsVm {
    id?: number;
    name?: string;
    productStock?: ProductStock;
    units?: number | undefined;
    unitType?: number;
    productStockId?: number;
    productStockSearchItems?: ProductStock[];
}

export class CreateCalledIngredientCommand implements ICreateCalledIngredientCommand {
    name?: string | undefined;
    recipeId?: number;

    constructor(data?: ICreateCalledIngredientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.recipeId = _data["recipeId"];
        }
    }

    static fromJS(data: any): CreateCalledIngredientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCalledIngredientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["recipeId"] = this.recipeId;
        return data;
    }
}

export interface ICreateCalledIngredientCommand {
    name?: string | undefined;
    recipeId?: number;
}

export class UpdateCalledIngredientCommand implements IUpdateCalledIngredientCommand {
    id?: number;
    name?: string | undefined;
    units?: number;

    constructor(data?: IUpdateCalledIngredientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): UpdateCalledIngredientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCalledIngredientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["units"] = this.units;
        return data;
    }
}

export interface IUpdateCalledIngredientCommand {
    id?: number;
    name?: string | undefined;
    units?: number;
}

export class UpdateCalledIngredientDetailsCommand implements IUpdateCalledIngredientDetailsCommand {
    id?: number;
    unitType?: UnitType;
    productStockId?: number | undefined;
    name?: string | undefined;
    units?: number;

    constructor(data?: IUpdateCalledIngredientDetailsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitType = _data["unitType"];
            this.productStockId = _data["productStockId"];
            this.name = _data["name"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): UpdateCalledIngredientDetailsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCalledIngredientDetailsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitType"] = this.unitType;
        data["productStockId"] = this.productStockId;
        data["name"] = this.name;
        data["units"] = this.units;
        return data;
    }
}

export interface IUpdateCalledIngredientDetailsCommand {
    id?: number;
    unitType?: UnitType;
    productStockId?: number | undefined;
    name?: string | undefined;
    units?: number;
}

export class GetChatResponseVm implements IGetChatResponseVm {
    chatConversationId?: number;
    createNewChat?: boolean;
    error?: boolean;
    dirty?: boolean;
    navigateToPage?: string;
    previousMessages?: ChatMessageVm[];
    responseMessage?: ChatMessageVm;

    constructor(data?: IGetChatResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatConversationId = _data["chatConversationId"];
            this.createNewChat = _data["createNewChat"];
            this.error = _data["error"];
            this.dirty = _data["dirty"];
            this.navigateToPage = _data["navigateToPage"];
            if (Array.isArray(_data["previousMessages"])) {
                this.previousMessages = [] as any;
                for (let item of _data["previousMessages"])
                    this.previousMessages!.push(ChatMessageVm.fromJS(item));
            }
            this.responseMessage = _data["responseMessage"] ? ChatMessageVm.fromJS(_data["responseMessage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetChatResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new GetChatResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatConversationId"] = this.chatConversationId;
        data["createNewChat"] = this.createNewChat;
        data["error"] = this.error;
        data["dirty"] = this.dirty;
        data["navigateToPage"] = this.navigateToPage;
        if (Array.isArray(this.previousMessages)) {
            data["previousMessages"] = [];
            for (let item of this.previousMessages)
                data["previousMessages"].push(item.toJSON());
        }
        data["responseMessage"] = this.responseMessage ? this.responseMessage.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetChatResponseVm {
    chatConversationId?: number;
    createNewChat?: boolean;
    error?: boolean;
    dirty?: boolean;
    navigateToPage?: string;
    previousMessages?: ChatMessageVm[];
    responseMessage?: ChatMessageVm;
}

export class ChatMessageVm implements IChatMessageVm {
    from?: number;
    message?: string;

    constructor(data?: IChatMessageVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ChatMessageVm {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["message"] = this.message;
        return data;
    }
}

export interface IChatMessageVm {
    from?: number;
    message?: string;
}

export class GetChatResponseQuery implements IGetChatResponseQuery {
    previousMessages?: ChatMessageVm[];
    chatMessage?: ChatMessageVm;
    chatConversationId?: number | undefined;
    currentUrl?: string;

    constructor(data?: IGetChatResponseQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["previousMessages"])) {
                this.previousMessages = [] as any;
                for (let item of _data["previousMessages"])
                    this.previousMessages!.push(ChatMessageVm.fromJS(item));
            }
            this.chatMessage = _data["chatMessage"] ? ChatMessageVm.fromJS(_data["chatMessage"]) : <any>undefined;
            this.chatConversationId = _data["chatConversationId"];
            this.currentUrl = _data["currentUrl"];
        }
    }

    static fromJS(data: any): GetChatResponseQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetChatResponseQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.previousMessages)) {
            data["previousMessages"] = [];
            for (let item of this.previousMessages)
                data["previousMessages"].push(item.toJSON());
        }
        data["chatMessage"] = this.chatMessage ? this.chatMessage.toJSON() : <any>undefined;
        data["chatConversationId"] = this.chatConversationId;
        data["currentUrl"] = this.currentUrl;
        return data;
    }
}

export interface IGetChatResponseQuery {
    previousMessages?: ChatMessageVm[];
    chatMessage?: ChatMessageVm;
    chatConversationId?: number | undefined;
    currentUrl?: string;
}

export class GetChatTextFromSpeechVm implements IGetChatTextFromSpeechVm {
    text?: string;

    constructor(data?: IGetChatTextFromSpeechVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): GetChatTextFromSpeechVm {
        data = typeof data === 'object' ? data : {};
        let result = new GetChatTextFromSpeechVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface IGetChatTextFromSpeechVm {
    text?: string;
}

export abstract class IHeaderDictionary implements IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];

    constructor(data?: IIHeaderDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Item"])) {
                this.item = [] as any;
                for (let item of _data["Item"])
                    this.item!.push(item);
            }
            this.contentLength = _data["ContentLength"];
            if (Array.isArray(_data["Accept"])) {
                this.accept = [] as any;
                for (let item of _data["Accept"])
                    this.accept!.push(item);
            }
            if (Array.isArray(_data["AcceptCharset"])) {
                this.acceptCharset = [] as any;
                for (let item of _data["AcceptCharset"])
                    this.acceptCharset!.push(item);
            }
            if (Array.isArray(_data["AcceptEncoding"])) {
                this.acceptEncoding = [] as any;
                for (let item of _data["AcceptEncoding"])
                    this.acceptEncoding!.push(item);
            }
            if (Array.isArray(_data["AcceptLanguage"])) {
                this.acceptLanguage = [] as any;
                for (let item of _data["AcceptLanguage"])
                    this.acceptLanguage!.push(item);
            }
            if (Array.isArray(_data["AcceptRanges"])) {
                this.acceptRanges = [] as any;
                for (let item of _data["AcceptRanges"])
                    this.acceptRanges!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowCredentials"])) {
                this.accessControlAllowCredentials = [] as any;
                for (let item of _data["AccessControlAllowCredentials"])
                    this.accessControlAllowCredentials!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowHeaders"])) {
                this.accessControlAllowHeaders = [] as any;
                for (let item of _data["AccessControlAllowHeaders"])
                    this.accessControlAllowHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowMethods"])) {
                this.accessControlAllowMethods = [] as any;
                for (let item of _data["AccessControlAllowMethods"])
                    this.accessControlAllowMethods!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowOrigin"])) {
                this.accessControlAllowOrigin = [] as any;
                for (let item of _data["AccessControlAllowOrigin"])
                    this.accessControlAllowOrigin!.push(item);
            }
            if (Array.isArray(_data["AccessControlExposeHeaders"])) {
                this.accessControlExposeHeaders = [] as any;
                for (let item of _data["AccessControlExposeHeaders"])
                    this.accessControlExposeHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlMaxAge"])) {
                this.accessControlMaxAge = [] as any;
                for (let item of _data["AccessControlMaxAge"])
                    this.accessControlMaxAge!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestHeaders"])) {
                this.accessControlRequestHeaders = [] as any;
                for (let item of _data["AccessControlRequestHeaders"])
                    this.accessControlRequestHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestMethod"])) {
                this.accessControlRequestMethod = [] as any;
                for (let item of _data["AccessControlRequestMethod"])
                    this.accessControlRequestMethod!.push(item);
            }
            if (Array.isArray(_data["Age"])) {
                this.age = [] as any;
                for (let item of _data["Age"])
                    this.age!.push(item);
            }
            if (Array.isArray(_data["Allow"])) {
                this.allow = [] as any;
                for (let item of _data["Allow"])
                    this.allow!.push(item);
            }
            if (Array.isArray(_data["AltSvc"])) {
                this.altSvc = [] as any;
                for (let item of _data["AltSvc"])
                    this.altSvc!.push(item);
            }
            if (Array.isArray(_data["Authorization"])) {
                this.authorization = [] as any;
                for (let item of _data["Authorization"])
                    this.authorization!.push(item);
            }
            if (Array.isArray(_data["Baggage"])) {
                this.baggage = [] as any;
                for (let item of _data["Baggage"])
                    this.baggage!.push(item);
            }
            if (Array.isArray(_data["CacheControl"])) {
                this.cacheControl = [] as any;
                for (let item of _data["CacheControl"])
                    this.cacheControl!.push(item);
            }
            if (Array.isArray(_data["Connection"])) {
                this.connection = [] as any;
                for (let item of _data["Connection"])
                    this.connection!.push(item);
            }
            if (Array.isArray(_data["ContentDisposition"])) {
                this.contentDisposition = [] as any;
                for (let item of _data["ContentDisposition"])
                    this.contentDisposition!.push(item);
            }
            if (Array.isArray(_data["ContentEncoding"])) {
                this.contentEncoding = [] as any;
                for (let item of _data["ContentEncoding"])
                    this.contentEncoding!.push(item);
            }
            if (Array.isArray(_data["ContentLanguage"])) {
                this.contentLanguage = [] as any;
                for (let item of _data["ContentLanguage"])
                    this.contentLanguage!.push(item);
            }
            if (Array.isArray(_data["ContentLocation"])) {
                this.contentLocation = [] as any;
                for (let item of _data["ContentLocation"])
                    this.contentLocation!.push(item);
            }
            if (Array.isArray(_data["ContentMD5"])) {
                this.contentMD5 = [] as any;
                for (let item of _data["ContentMD5"])
                    this.contentMD5!.push(item);
            }
            if (Array.isArray(_data["ContentRange"])) {
                this.contentRange = [] as any;
                for (let item of _data["ContentRange"])
                    this.contentRange!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicy"])) {
                this.contentSecurityPolicy = [] as any;
                for (let item of _data["ContentSecurityPolicy"])
                    this.contentSecurityPolicy!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicyReportOnly"])) {
                this.contentSecurityPolicyReportOnly = [] as any;
                for (let item of _data["ContentSecurityPolicyReportOnly"])
                    this.contentSecurityPolicyReportOnly!.push(item);
            }
            if (Array.isArray(_data["ContentType"])) {
                this.contentType = [] as any;
                for (let item of _data["ContentType"])
                    this.contentType!.push(item);
            }
            if (Array.isArray(_data["CorrelationContext"])) {
                this.correlationContext = [] as any;
                for (let item of _data["CorrelationContext"])
                    this.correlationContext!.push(item);
            }
            if (Array.isArray(_data["Cookie"])) {
                this.cookie = [] as any;
                for (let item of _data["Cookie"])
                    this.cookie!.push(item);
            }
            if (Array.isArray(_data["Date"])) {
                this.date = [] as any;
                for (let item of _data["Date"])
                    this.date!.push(item);
            }
            if (Array.isArray(_data["ETag"])) {
                this.eTag = [] as any;
                for (let item of _data["ETag"])
                    this.eTag!.push(item);
            }
            if (Array.isArray(_data["Expires"])) {
                this.expires = [] as any;
                for (let item of _data["Expires"])
                    this.expires!.push(item);
            }
            if (Array.isArray(_data["Expect"])) {
                this.expect = [] as any;
                for (let item of _data["Expect"])
                    this.expect!.push(item);
            }
            if (Array.isArray(_data["From"])) {
                this.from = [] as any;
                for (let item of _data["From"])
                    this.from!.push(item);
            }
            if (Array.isArray(_data["GrpcAcceptEncoding"])) {
                this.grpcAcceptEncoding = [] as any;
                for (let item of _data["GrpcAcceptEncoding"])
                    this.grpcAcceptEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcEncoding"])) {
                this.grpcEncoding = [] as any;
                for (let item of _data["GrpcEncoding"])
                    this.grpcEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcMessage"])) {
                this.grpcMessage = [] as any;
                for (let item of _data["GrpcMessage"])
                    this.grpcMessage!.push(item);
            }
            if (Array.isArray(_data["GrpcStatus"])) {
                this.grpcStatus = [] as any;
                for (let item of _data["GrpcStatus"])
                    this.grpcStatus!.push(item);
            }
            if (Array.isArray(_data["GrpcTimeout"])) {
                this.grpcTimeout = [] as any;
                for (let item of _data["GrpcTimeout"])
                    this.grpcTimeout!.push(item);
            }
            if (Array.isArray(_data["Host"])) {
                this.host = [] as any;
                for (let item of _data["Host"])
                    this.host!.push(item);
            }
            if (Array.isArray(_data["KeepAlive"])) {
                this.keepAlive = [] as any;
                for (let item of _data["KeepAlive"])
                    this.keepAlive!.push(item);
            }
            if (Array.isArray(_data["IfMatch"])) {
                this.ifMatch = [] as any;
                for (let item of _data["IfMatch"])
                    this.ifMatch!.push(item);
            }
            if (Array.isArray(_data["IfModifiedSince"])) {
                this.ifModifiedSince = [] as any;
                for (let item of _data["IfModifiedSince"])
                    this.ifModifiedSince!.push(item);
            }
            if (Array.isArray(_data["IfNoneMatch"])) {
                this.ifNoneMatch = [] as any;
                for (let item of _data["IfNoneMatch"])
                    this.ifNoneMatch!.push(item);
            }
            if (Array.isArray(_data["IfRange"])) {
                this.ifRange = [] as any;
                for (let item of _data["IfRange"])
                    this.ifRange!.push(item);
            }
            if (Array.isArray(_data["IfUnmodifiedSince"])) {
                this.ifUnmodifiedSince = [] as any;
                for (let item of _data["IfUnmodifiedSince"])
                    this.ifUnmodifiedSince!.push(item);
            }
            if (Array.isArray(_data["LastModified"])) {
                this.lastModified = [] as any;
                for (let item of _data["LastModified"])
                    this.lastModified!.push(item);
            }
            if (Array.isArray(_data["Link"])) {
                this.link = [] as any;
                for (let item of _data["Link"])
                    this.link!.push(item);
            }
            if (Array.isArray(_data["Location"])) {
                this.location = [] as any;
                for (let item of _data["Location"])
                    this.location!.push(item);
            }
            if (Array.isArray(_data["MaxForwards"])) {
                this.maxForwards = [] as any;
                for (let item of _data["MaxForwards"])
                    this.maxForwards!.push(item);
            }
            if (Array.isArray(_data["Origin"])) {
                this.origin = [] as any;
                for (let item of _data["Origin"])
                    this.origin!.push(item);
            }
            if (Array.isArray(_data["Pragma"])) {
                this.pragma = [] as any;
                for (let item of _data["Pragma"])
                    this.pragma!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthenticate"])) {
                this.proxyAuthenticate = [] as any;
                for (let item of _data["ProxyAuthenticate"])
                    this.proxyAuthenticate!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthorization"])) {
                this.proxyAuthorization = [] as any;
                for (let item of _data["ProxyAuthorization"])
                    this.proxyAuthorization!.push(item);
            }
            if (Array.isArray(_data["ProxyConnection"])) {
                this.proxyConnection = [] as any;
                for (let item of _data["ProxyConnection"])
                    this.proxyConnection!.push(item);
            }
            if (Array.isArray(_data["Range"])) {
                this.range = [] as any;
                for (let item of _data["Range"])
                    this.range!.push(item);
            }
            if (Array.isArray(_data["Referer"])) {
                this.referer = [] as any;
                for (let item of _data["Referer"])
                    this.referer!.push(item);
            }
            if (Array.isArray(_data["RetryAfter"])) {
                this.retryAfter = [] as any;
                for (let item of _data["RetryAfter"])
                    this.retryAfter!.push(item);
            }
            if (Array.isArray(_data["RequestId"])) {
                this.requestId = [] as any;
                for (let item of _data["RequestId"])
                    this.requestId!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketAccept"])) {
                this.secWebSocketAccept = [] as any;
                for (let item of _data["SecWebSocketAccept"])
                    this.secWebSocketAccept!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketKey"])) {
                this.secWebSocketKey = [] as any;
                for (let item of _data["SecWebSocketKey"])
                    this.secWebSocketKey!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketProtocol"])) {
                this.secWebSocketProtocol = [] as any;
                for (let item of _data["SecWebSocketProtocol"])
                    this.secWebSocketProtocol!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketVersion"])) {
                this.secWebSocketVersion = [] as any;
                for (let item of _data["SecWebSocketVersion"])
                    this.secWebSocketVersion!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketExtensions"])) {
                this.secWebSocketExtensions = [] as any;
                for (let item of _data["SecWebSocketExtensions"])
                    this.secWebSocketExtensions!.push(item);
            }
            if (Array.isArray(_data["Server"])) {
                this.server = [] as any;
                for (let item of _data["Server"])
                    this.server!.push(item);
            }
            if (Array.isArray(_data["SetCookie"])) {
                this.setCookie = [] as any;
                for (let item of _data["SetCookie"])
                    this.setCookie!.push(item);
            }
            if (Array.isArray(_data["StrictTransportSecurity"])) {
                this.strictTransportSecurity = [] as any;
                for (let item of _data["StrictTransportSecurity"])
                    this.strictTransportSecurity!.push(item);
            }
            if (Array.isArray(_data["TE"])) {
                this.tE = [] as any;
                for (let item of _data["TE"])
                    this.tE!.push(item);
            }
            if (Array.isArray(_data["Trailer"])) {
                this.trailer = [] as any;
                for (let item of _data["Trailer"])
                    this.trailer!.push(item);
            }
            if (Array.isArray(_data["TransferEncoding"])) {
                this.transferEncoding = [] as any;
                for (let item of _data["TransferEncoding"])
                    this.transferEncoding!.push(item);
            }
            if (Array.isArray(_data["Translate"])) {
                this.translate = [] as any;
                for (let item of _data["Translate"])
                    this.translate!.push(item);
            }
            if (Array.isArray(_data["TraceParent"])) {
                this.traceParent = [] as any;
                for (let item of _data["TraceParent"])
                    this.traceParent!.push(item);
            }
            if (Array.isArray(_data["TraceState"])) {
                this.traceState = [] as any;
                for (let item of _data["TraceState"])
                    this.traceState!.push(item);
            }
            if (Array.isArray(_data["Upgrade"])) {
                this.upgrade = [] as any;
                for (let item of _data["Upgrade"])
                    this.upgrade!.push(item);
            }
            if (Array.isArray(_data["UpgradeInsecureRequests"])) {
                this.upgradeInsecureRequests = [] as any;
                for (let item of _data["UpgradeInsecureRequests"])
                    this.upgradeInsecureRequests!.push(item);
            }
            if (Array.isArray(_data["UserAgent"])) {
                this.userAgent = [] as any;
                for (let item of _data["UserAgent"])
                    this.userAgent!.push(item);
            }
            if (Array.isArray(_data["Vary"])) {
                this.vary = [] as any;
                for (let item of _data["Vary"])
                    this.vary!.push(item);
            }
            if (Array.isArray(_data["Via"])) {
                this.via = [] as any;
                for (let item of _data["Via"])
                    this.via!.push(item);
            }
            if (Array.isArray(_data["Warning"])) {
                this.warning = [] as any;
                for (let item of _data["Warning"])
                    this.warning!.push(item);
            }
            if (Array.isArray(_data["WebSocketSubProtocols"])) {
                this.webSocketSubProtocols = [] as any;
                for (let item of _data["WebSocketSubProtocols"])
                    this.webSocketSubProtocols!.push(item);
            }
            if (Array.isArray(_data["WWWAuthenticate"])) {
                this.wWWAuthenticate = [] as any;
                for (let item of _data["WWWAuthenticate"])
                    this.wWWAuthenticate!.push(item);
            }
            if (Array.isArray(_data["XContentTypeOptions"])) {
                this.xContentTypeOptions = [] as any;
                for (let item of _data["XContentTypeOptions"])
                    this.xContentTypeOptions!.push(item);
            }
            if (Array.isArray(_data["XFrameOptions"])) {
                this.xFrameOptions = [] as any;
                for (let item of _data["XFrameOptions"])
                    this.xFrameOptions!.push(item);
            }
            if (Array.isArray(_data["XPoweredBy"])) {
                this.xPoweredBy = [] as any;
                for (let item of _data["XPoweredBy"])
                    this.xPoweredBy!.push(item);
            }
            if (Array.isArray(_data["XRequestedWith"])) {
                this.xRequestedWith = [] as any;
                for (let item of _data["XRequestedWith"])
                    this.xRequestedWith!.push(item);
            }
            if (Array.isArray(_data["XUACompatible"])) {
                this.xUACompatible = [] as any;
                for (let item of _data["XUACompatible"])
                    this.xUACompatible!.push(item);
            }
            if (Array.isArray(_data["XXSSProtection"])) {
                this.xXSSProtection = [] as any;
                for (let item of _data["XXSSProtection"])
                    this.xXSSProtection!.push(item);
            }
        }
    }

    static fromJS(data: any): IHeaderDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IHeaderDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item)) {
            data["Item"] = [];
            for (let item of this.item)
                data["Item"].push(item);
        }
        data["ContentLength"] = this.contentLength;
        if (Array.isArray(this.accept)) {
            data["Accept"] = [];
            for (let item of this.accept)
                data["Accept"].push(item);
        }
        if (Array.isArray(this.acceptCharset)) {
            data["AcceptCharset"] = [];
            for (let item of this.acceptCharset)
                data["AcceptCharset"].push(item);
        }
        if (Array.isArray(this.acceptEncoding)) {
            data["AcceptEncoding"] = [];
            for (let item of this.acceptEncoding)
                data["AcceptEncoding"].push(item);
        }
        if (Array.isArray(this.acceptLanguage)) {
            data["AcceptLanguage"] = [];
            for (let item of this.acceptLanguage)
                data["AcceptLanguage"].push(item);
        }
        if (Array.isArray(this.acceptRanges)) {
            data["AcceptRanges"] = [];
            for (let item of this.acceptRanges)
                data["AcceptRanges"].push(item);
        }
        if (Array.isArray(this.accessControlAllowCredentials)) {
            data["AccessControlAllowCredentials"] = [];
            for (let item of this.accessControlAllowCredentials)
                data["AccessControlAllowCredentials"].push(item);
        }
        if (Array.isArray(this.accessControlAllowHeaders)) {
            data["AccessControlAllowHeaders"] = [];
            for (let item of this.accessControlAllowHeaders)
                data["AccessControlAllowHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlAllowMethods)) {
            data["AccessControlAllowMethods"] = [];
            for (let item of this.accessControlAllowMethods)
                data["AccessControlAllowMethods"].push(item);
        }
        if (Array.isArray(this.accessControlAllowOrigin)) {
            data["AccessControlAllowOrigin"] = [];
            for (let item of this.accessControlAllowOrigin)
                data["AccessControlAllowOrigin"].push(item);
        }
        if (Array.isArray(this.accessControlExposeHeaders)) {
            data["AccessControlExposeHeaders"] = [];
            for (let item of this.accessControlExposeHeaders)
                data["AccessControlExposeHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlMaxAge)) {
            data["AccessControlMaxAge"] = [];
            for (let item of this.accessControlMaxAge)
                data["AccessControlMaxAge"].push(item);
        }
        if (Array.isArray(this.accessControlRequestHeaders)) {
            data["AccessControlRequestHeaders"] = [];
            for (let item of this.accessControlRequestHeaders)
                data["AccessControlRequestHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlRequestMethod)) {
            data["AccessControlRequestMethod"] = [];
            for (let item of this.accessControlRequestMethod)
                data["AccessControlRequestMethod"].push(item);
        }
        if (Array.isArray(this.age)) {
            data["Age"] = [];
            for (let item of this.age)
                data["Age"].push(item);
        }
        if (Array.isArray(this.allow)) {
            data["Allow"] = [];
            for (let item of this.allow)
                data["Allow"].push(item);
        }
        if (Array.isArray(this.altSvc)) {
            data["AltSvc"] = [];
            for (let item of this.altSvc)
                data["AltSvc"].push(item);
        }
        if (Array.isArray(this.authorization)) {
            data["Authorization"] = [];
            for (let item of this.authorization)
                data["Authorization"].push(item);
        }
        if (Array.isArray(this.baggage)) {
            data["Baggage"] = [];
            for (let item of this.baggage)
                data["Baggage"].push(item);
        }
        if (Array.isArray(this.cacheControl)) {
            data["CacheControl"] = [];
            for (let item of this.cacheControl)
                data["CacheControl"].push(item);
        }
        if (Array.isArray(this.connection)) {
            data["Connection"] = [];
            for (let item of this.connection)
                data["Connection"].push(item);
        }
        if (Array.isArray(this.contentDisposition)) {
            data["ContentDisposition"] = [];
            for (let item of this.contentDisposition)
                data["ContentDisposition"].push(item);
        }
        if (Array.isArray(this.contentEncoding)) {
            data["ContentEncoding"] = [];
            for (let item of this.contentEncoding)
                data["ContentEncoding"].push(item);
        }
        if (Array.isArray(this.contentLanguage)) {
            data["ContentLanguage"] = [];
            for (let item of this.contentLanguage)
                data["ContentLanguage"].push(item);
        }
        if (Array.isArray(this.contentLocation)) {
            data["ContentLocation"] = [];
            for (let item of this.contentLocation)
                data["ContentLocation"].push(item);
        }
        if (Array.isArray(this.contentMD5)) {
            data["ContentMD5"] = [];
            for (let item of this.contentMD5)
                data["ContentMD5"].push(item);
        }
        if (Array.isArray(this.contentRange)) {
            data["ContentRange"] = [];
            for (let item of this.contentRange)
                data["ContentRange"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicy)) {
            data["ContentSecurityPolicy"] = [];
            for (let item of this.contentSecurityPolicy)
                data["ContentSecurityPolicy"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicyReportOnly)) {
            data["ContentSecurityPolicyReportOnly"] = [];
            for (let item of this.contentSecurityPolicyReportOnly)
                data["ContentSecurityPolicyReportOnly"].push(item);
        }
        if (Array.isArray(this.contentType)) {
            data["ContentType"] = [];
            for (let item of this.contentType)
                data["ContentType"].push(item);
        }
        if (Array.isArray(this.correlationContext)) {
            data["CorrelationContext"] = [];
            for (let item of this.correlationContext)
                data["CorrelationContext"].push(item);
        }
        if (Array.isArray(this.cookie)) {
            data["Cookie"] = [];
            for (let item of this.cookie)
                data["Cookie"].push(item);
        }
        if (Array.isArray(this.date)) {
            data["Date"] = [];
            for (let item of this.date)
                data["Date"].push(item);
        }
        if (Array.isArray(this.eTag)) {
            data["ETag"] = [];
            for (let item of this.eTag)
                data["ETag"].push(item);
        }
        if (Array.isArray(this.expires)) {
            data["Expires"] = [];
            for (let item of this.expires)
                data["Expires"].push(item);
        }
        if (Array.isArray(this.expect)) {
            data["Expect"] = [];
            for (let item of this.expect)
                data["Expect"].push(item);
        }
        if (Array.isArray(this.from)) {
            data["From"] = [];
            for (let item of this.from)
                data["From"].push(item);
        }
        if (Array.isArray(this.grpcAcceptEncoding)) {
            data["GrpcAcceptEncoding"] = [];
            for (let item of this.grpcAcceptEncoding)
                data["GrpcAcceptEncoding"].push(item);
        }
        if (Array.isArray(this.grpcEncoding)) {
            data["GrpcEncoding"] = [];
            for (let item of this.grpcEncoding)
                data["GrpcEncoding"].push(item);
        }
        if (Array.isArray(this.grpcMessage)) {
            data["GrpcMessage"] = [];
            for (let item of this.grpcMessage)
                data["GrpcMessage"].push(item);
        }
        if (Array.isArray(this.grpcStatus)) {
            data["GrpcStatus"] = [];
            for (let item of this.grpcStatus)
                data["GrpcStatus"].push(item);
        }
        if (Array.isArray(this.grpcTimeout)) {
            data["GrpcTimeout"] = [];
            for (let item of this.grpcTimeout)
                data["GrpcTimeout"].push(item);
        }
        if (Array.isArray(this.host)) {
            data["Host"] = [];
            for (let item of this.host)
                data["Host"].push(item);
        }
        if (Array.isArray(this.keepAlive)) {
            data["KeepAlive"] = [];
            for (let item of this.keepAlive)
                data["KeepAlive"].push(item);
        }
        if (Array.isArray(this.ifMatch)) {
            data["IfMatch"] = [];
            for (let item of this.ifMatch)
                data["IfMatch"].push(item);
        }
        if (Array.isArray(this.ifModifiedSince)) {
            data["IfModifiedSince"] = [];
            for (let item of this.ifModifiedSince)
                data["IfModifiedSince"].push(item);
        }
        if (Array.isArray(this.ifNoneMatch)) {
            data["IfNoneMatch"] = [];
            for (let item of this.ifNoneMatch)
                data["IfNoneMatch"].push(item);
        }
        if (Array.isArray(this.ifRange)) {
            data["IfRange"] = [];
            for (let item of this.ifRange)
                data["IfRange"].push(item);
        }
        if (Array.isArray(this.ifUnmodifiedSince)) {
            data["IfUnmodifiedSince"] = [];
            for (let item of this.ifUnmodifiedSince)
                data["IfUnmodifiedSince"].push(item);
        }
        if (Array.isArray(this.lastModified)) {
            data["LastModified"] = [];
            for (let item of this.lastModified)
                data["LastModified"].push(item);
        }
        if (Array.isArray(this.link)) {
            data["Link"] = [];
            for (let item of this.link)
                data["Link"].push(item);
        }
        if (Array.isArray(this.location)) {
            data["Location"] = [];
            for (let item of this.location)
                data["Location"].push(item);
        }
        if (Array.isArray(this.maxForwards)) {
            data["MaxForwards"] = [];
            for (let item of this.maxForwards)
                data["MaxForwards"].push(item);
        }
        if (Array.isArray(this.origin)) {
            data["Origin"] = [];
            for (let item of this.origin)
                data["Origin"].push(item);
        }
        if (Array.isArray(this.pragma)) {
            data["Pragma"] = [];
            for (let item of this.pragma)
                data["Pragma"].push(item);
        }
        if (Array.isArray(this.proxyAuthenticate)) {
            data["ProxyAuthenticate"] = [];
            for (let item of this.proxyAuthenticate)
                data["ProxyAuthenticate"].push(item);
        }
        if (Array.isArray(this.proxyAuthorization)) {
            data["ProxyAuthorization"] = [];
            for (let item of this.proxyAuthorization)
                data["ProxyAuthorization"].push(item);
        }
        if (Array.isArray(this.proxyConnection)) {
            data["ProxyConnection"] = [];
            for (let item of this.proxyConnection)
                data["ProxyConnection"].push(item);
        }
        if (Array.isArray(this.range)) {
            data["Range"] = [];
            for (let item of this.range)
                data["Range"].push(item);
        }
        if (Array.isArray(this.referer)) {
            data["Referer"] = [];
            for (let item of this.referer)
                data["Referer"].push(item);
        }
        if (Array.isArray(this.retryAfter)) {
            data["RetryAfter"] = [];
            for (let item of this.retryAfter)
                data["RetryAfter"].push(item);
        }
        if (Array.isArray(this.requestId)) {
            data["RequestId"] = [];
            for (let item of this.requestId)
                data["RequestId"].push(item);
        }
        if (Array.isArray(this.secWebSocketAccept)) {
            data["SecWebSocketAccept"] = [];
            for (let item of this.secWebSocketAccept)
                data["SecWebSocketAccept"].push(item);
        }
        if (Array.isArray(this.secWebSocketKey)) {
            data["SecWebSocketKey"] = [];
            for (let item of this.secWebSocketKey)
                data["SecWebSocketKey"].push(item);
        }
        if (Array.isArray(this.secWebSocketProtocol)) {
            data["SecWebSocketProtocol"] = [];
            for (let item of this.secWebSocketProtocol)
                data["SecWebSocketProtocol"].push(item);
        }
        if (Array.isArray(this.secWebSocketVersion)) {
            data["SecWebSocketVersion"] = [];
            for (let item of this.secWebSocketVersion)
                data["SecWebSocketVersion"].push(item);
        }
        if (Array.isArray(this.secWebSocketExtensions)) {
            data["SecWebSocketExtensions"] = [];
            for (let item of this.secWebSocketExtensions)
                data["SecWebSocketExtensions"].push(item);
        }
        if (Array.isArray(this.server)) {
            data["Server"] = [];
            for (let item of this.server)
                data["Server"].push(item);
        }
        if (Array.isArray(this.setCookie)) {
            data["SetCookie"] = [];
            for (let item of this.setCookie)
                data["SetCookie"].push(item);
        }
        if (Array.isArray(this.strictTransportSecurity)) {
            data["StrictTransportSecurity"] = [];
            for (let item of this.strictTransportSecurity)
                data["StrictTransportSecurity"].push(item);
        }
        if (Array.isArray(this.tE)) {
            data["TE"] = [];
            for (let item of this.tE)
                data["TE"].push(item);
        }
        if (Array.isArray(this.trailer)) {
            data["Trailer"] = [];
            for (let item of this.trailer)
                data["Trailer"].push(item);
        }
        if (Array.isArray(this.transferEncoding)) {
            data["TransferEncoding"] = [];
            for (let item of this.transferEncoding)
                data["TransferEncoding"].push(item);
        }
        if (Array.isArray(this.translate)) {
            data["Translate"] = [];
            for (let item of this.translate)
                data["Translate"].push(item);
        }
        if (Array.isArray(this.traceParent)) {
            data["TraceParent"] = [];
            for (let item of this.traceParent)
                data["TraceParent"].push(item);
        }
        if (Array.isArray(this.traceState)) {
            data["TraceState"] = [];
            for (let item of this.traceState)
                data["TraceState"].push(item);
        }
        if (Array.isArray(this.upgrade)) {
            data["Upgrade"] = [];
            for (let item of this.upgrade)
                data["Upgrade"].push(item);
        }
        if (Array.isArray(this.upgradeInsecureRequests)) {
            data["UpgradeInsecureRequests"] = [];
            for (let item of this.upgradeInsecureRequests)
                data["UpgradeInsecureRequests"].push(item);
        }
        if (Array.isArray(this.userAgent)) {
            data["UserAgent"] = [];
            for (let item of this.userAgent)
                data["UserAgent"].push(item);
        }
        if (Array.isArray(this.vary)) {
            data["Vary"] = [];
            for (let item of this.vary)
                data["Vary"].push(item);
        }
        if (Array.isArray(this.via)) {
            data["Via"] = [];
            for (let item of this.via)
                data["Via"].push(item);
        }
        if (Array.isArray(this.warning)) {
            data["Warning"] = [];
            for (let item of this.warning)
                data["Warning"].push(item);
        }
        if (Array.isArray(this.webSocketSubProtocols)) {
            data["WebSocketSubProtocols"] = [];
            for (let item of this.webSocketSubProtocols)
                data["WebSocketSubProtocols"].push(item);
        }
        if (Array.isArray(this.wWWAuthenticate)) {
            data["WWWAuthenticate"] = [];
            for (let item of this.wWWAuthenticate)
                data["WWWAuthenticate"].push(item);
        }
        if (Array.isArray(this.xContentTypeOptions)) {
            data["XContentTypeOptions"] = [];
            for (let item of this.xContentTypeOptions)
                data["XContentTypeOptions"].push(item);
        }
        if (Array.isArray(this.xFrameOptions)) {
            data["XFrameOptions"] = [];
            for (let item of this.xFrameOptions)
                data["XFrameOptions"].push(item);
        }
        if (Array.isArray(this.xPoweredBy)) {
            data["XPoweredBy"] = [];
            for (let item of this.xPoweredBy)
                data["XPoweredBy"].push(item);
        }
        if (Array.isArray(this.xRequestedWith)) {
            data["XRequestedWith"] = [];
            for (let item of this.xRequestedWith)
                data["XRequestedWith"].push(item);
        }
        if (Array.isArray(this.xUACompatible)) {
            data["XUACompatible"] = [];
            for (let item of this.xUACompatible)
                data["XUACompatible"].push(item);
        }
        if (Array.isArray(this.xXSSProtection)) {
            data["XXSSProtection"] = [];
            for (let item of this.xXSSProtection)
                data["XXSSProtection"].push(item);
        }
        return data;
    }
}

export interface IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];
}

export class CompletedOrdersVm implements ICompletedOrdersVm {
    completedOrders?: CompletedOrderDto[];

    constructor(data?: ICompletedOrdersVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["completedOrders"])) {
                this.completedOrders = [] as any;
                for (let item of _data["completedOrders"])
                    this.completedOrders!.push(CompletedOrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompletedOrdersVm {
        data = typeof data === 'object' ? data : {};
        let result = new CompletedOrdersVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.completedOrders)) {
            data["completedOrders"] = [];
            for (let item of this.completedOrders)
                data["completedOrders"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompletedOrdersVm {
    completedOrders?: CompletedOrderDto[];
}

export class CompletedOrderDto implements ICompletedOrderDto {
    id?: number;
    name?: string;
    userImport?: string | undefined;
    completedOrderProducts?: CompletedOrderProductDto[];

    constructor(data?: ICompletedOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userImport = _data["userImport"];
            if (Array.isArray(_data["completedOrderProducts"])) {
                this.completedOrderProducts = [] as any;
                for (let item of _data["completedOrderProducts"])
                    this.completedOrderProducts!.push(CompletedOrderProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompletedOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompletedOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userImport"] = this.userImport;
        if (Array.isArray(this.completedOrderProducts)) {
            data["completedOrderProducts"] = [];
            for (let item of this.completedOrderProducts)
                data["completedOrderProducts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompletedOrderDto {
    id?: number;
    name?: string;
    userImport?: string | undefined;
    completedOrderProducts?: CompletedOrderProductDto[];
}

export class CompletedOrderProductDto implements ICompletedOrderProductDto {
    id?: number;
    name?: string;
    walmartId?: number | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    walmartError?: string | undefined;
    completedOrderId?: number;
    product?: ProductDto | undefined;

    constructor(data?: ICompletedOrderProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.walmartId = _data["walmartId"];
            this.walmartItemResponse = _data["walmartItemResponse"];
            this.walmartSearchResponse = _data["walmartSearchResponse"];
            this.walmartError = _data["walmartError"];
            this.completedOrderId = _data["completedOrderId"];
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompletedOrderProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompletedOrderProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["walmartId"] = this.walmartId;
        data["walmartItemResponse"] = this.walmartItemResponse;
        data["walmartSearchResponse"] = this.walmartSearchResponse;
        data["walmartError"] = this.walmartError;
        data["completedOrderId"] = this.completedOrderId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompletedOrderProductDto {
    id?: number;
    name?: string;
    walmartId?: number | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    walmartError?: string | undefined;
    completedOrderId?: number;
    product?: ProductDto | undefined;
}

export class ProductDto implements IProductDto {
    id?: number;
    name?: string;
    walmartId?: number | undefined;
    walmartLink?: string | undefined;
    walmartSize?: string | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    error?: string | undefined;
    size?: number;
    price?: number;
    verified?: boolean;
    unitType?: number;
    productStockId?: number | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.walmartId = _data["walmartId"];
            this.walmartLink = _data["walmartLink"];
            this.walmartSize = _data["walmartSize"];
            this.walmartItemResponse = _data["walmartItemResponse"];
            this.walmartSearchResponse = _data["walmartSearchResponse"];
            this.error = _data["error"];
            this.size = _data["size"];
            this.price = _data["price"];
            this.verified = _data["verified"];
            this.unitType = _data["unitType"];
            this.productStockId = _data["productStockId"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["walmartId"] = this.walmartId;
        data["walmartLink"] = this.walmartLink;
        data["walmartSize"] = this.walmartSize;
        data["walmartItemResponse"] = this.walmartItemResponse;
        data["walmartSearchResponse"] = this.walmartSearchResponse;
        data["error"] = this.error;
        data["size"] = this.size;
        data["price"] = this.price;
        data["verified"] = this.verified;
        data["unitType"] = this.unitType;
        data["productStockId"] = this.productStockId;
        return data;
    }
}

export interface IProductDto {
    id?: number;
    name?: string;
    walmartId?: number | undefined;
    walmartLink?: string | undefined;
    walmartSize?: string | undefined;
    walmartItemResponse?: string | undefined;
    walmartSearchResponse?: string | undefined;
    error?: string | undefined;
    size?: number;
    price?: number;
    verified?: boolean;
    unitType?: number;
    productStockId?: number | undefined;
}

export class CreateCompletedOrderCommand implements ICreateCompletedOrderCommand {
    name?: string;
    userImport?: string | undefined;

    constructor(data?: ICreateCompletedOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.userImport = _data["userImport"];
        }
    }

    static fromJS(data: any): CreateCompletedOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompletedOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["userImport"] = this.userImport;
        return data;
    }
}

export interface ICreateCompletedOrderCommand {
    name?: string;
    userImport?: string | undefined;
}

export class UpdateCompletedOrderCommand implements IUpdateCompletedOrderCommand {
    id?: number;
    name?: string;
    userImport?: string | undefined;

    constructor(data?: IUpdateCompletedOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userImport = _data["userImport"];
        }
    }

    static fromJS(data: any): UpdateCompletedOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompletedOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userImport"] = this.userImport;
        return data;
    }
}

export interface IUpdateCompletedOrderCommand {
    id?: number;
    name?: string;
    userImport?: string | undefined;
}

export class CreateCompletedOrderProductCommand implements ICreateCompletedOrderProductCommand {
    name?: string | undefined;
    completedOrderId?: number;

    constructor(data?: ICreateCompletedOrderProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.completedOrderId = _data["completedOrderId"];
        }
    }

    static fromJS(data: any): CreateCompletedOrderProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompletedOrderProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["completedOrderId"] = this.completedOrderId;
        return data;
    }
}

export interface ICreateCompletedOrderProductCommand {
    name?: string | undefined;
    completedOrderId?: number;
}

export class UpdateCompletedOrderProductCommand implements IUpdateCompletedOrderProductCommand {
    id?: number;
    name?: string | undefined;
    walmartId?: number | undefined;

    constructor(data?: IUpdateCompletedOrderProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.walmartId = _data["walmartId"];
        }
    }

    static fromJS(data: any): UpdateCompletedOrderProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompletedOrderProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["walmartId"] = this.walmartId;
        return data;
    }
}

export interface IUpdateCompletedOrderProductCommand {
    id?: number;
    name?: string | undefined;
    walmartId?: number | undefined;
}

export class CookedRecipeCalledIngredientDetailsVm implements ICookedRecipeCalledIngredientDetailsVm {
    id?: number;
    cookedRecipeId?: number;
    calledIngredient?: CalledIngredientDto | undefined;
    productStock?: ProductStockDto | undefined;
    productStockId?: number | undefined;
    name?: string;
    unitType?: UnitType;
    units?: number;
    productStockSearchItems?: ProductStock[];

    constructor(data?: ICookedRecipeCalledIngredientDetailsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cookedRecipeId = _data["cookedRecipeId"];
            this.calledIngredient = _data["calledIngredient"] ? CalledIngredientDto.fromJS(_data["calledIngredient"]) : <any>undefined;
            this.productStock = _data["productStock"] ? ProductStockDto.fromJS(_data["productStock"]) : <any>undefined;
            this.productStockId = _data["productStockId"];
            this.name = _data["name"];
            this.unitType = _data["unitType"];
            this.units = _data["units"];
            if (Array.isArray(_data["productStockSearchItems"])) {
                this.productStockSearchItems = [] as any;
                for (let item of _data["productStockSearchItems"])
                    this.productStockSearchItems!.push(ProductStock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CookedRecipeCalledIngredientDetailsVm {
        data = typeof data === 'object' ? data : {};
        let result = new CookedRecipeCalledIngredientDetailsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cookedRecipeId"] = this.cookedRecipeId;
        data["calledIngredient"] = this.calledIngredient ? this.calledIngredient.toJSON() : <any>undefined;
        data["productStock"] = this.productStock ? this.productStock.toJSON() : <any>undefined;
        data["productStockId"] = this.productStockId;
        data["name"] = this.name;
        data["unitType"] = this.unitType;
        data["units"] = this.units;
        if (Array.isArray(this.productStockSearchItems)) {
            data["productStockSearchItems"] = [];
            for (let item of this.productStockSearchItems)
                data["productStockSearchItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICookedRecipeCalledIngredientDetailsVm {
    id?: number;
    cookedRecipeId?: number;
    calledIngredient?: CalledIngredientDto | undefined;
    productStock?: ProductStockDto | undefined;
    productStockId?: number | undefined;
    name?: string;
    unitType?: UnitType;
    units?: number;
    productStockSearchItems?: ProductStock[];
}

export class ProductStockDto implements IProductStockDto {
    id?: number;
    name?: string;
    units?: number;
    productId?: number | undefined;
    product?: ProductDto;

    constructor(data?: IProductStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.units = _data["units"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["units"] = this.units;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductStockDto {
    id?: number;
    name?: string;
    units?: number;
    productId?: number | undefined;
    product?: ProductDto;
}

export class CreateCookedRecipeCalledIngredientCommand implements ICreateCookedRecipeCalledIngredientCommand {
    name?: string | undefined;
    cookedRecipeId?: number;
    productStockId?: number | undefined;

    constructor(data?: ICreateCookedRecipeCalledIngredientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.cookedRecipeId = _data["cookedRecipeId"];
            this.productStockId = _data["productStockId"];
        }
    }

    static fromJS(data: any): CreateCookedRecipeCalledIngredientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCookedRecipeCalledIngredientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["cookedRecipeId"] = this.cookedRecipeId;
        data["productStockId"] = this.productStockId;
        return data;
    }
}

export interface ICreateCookedRecipeCalledIngredientCommand {
    name?: string | undefined;
    cookedRecipeId?: number;
    productStockId?: number | undefined;
}

export class UpdateCookedRecipeCalledIngredientCommand implements IUpdateCookedRecipeCalledIngredientCommand {
    id?: number;
    name?: string | undefined;
    units?: number | undefined;
    productStockId?: number | undefined;

    constructor(data?: IUpdateCookedRecipeCalledIngredientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.units = _data["units"];
            this.productStockId = _data["productStockId"];
        }
    }

    static fromJS(data: any): UpdateCookedRecipeCalledIngredientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCookedRecipeCalledIngredientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["units"] = this.units;
        data["productStockId"] = this.productStockId;
        return data;
    }
}

export interface IUpdateCookedRecipeCalledIngredientCommand {
    id?: number;
    name?: string | undefined;
    units?: number | undefined;
    productStockId?: number | undefined;
}

export class UpdateCookedRecipeCalledIngredientDetailsCommand implements IUpdateCookedRecipeCalledIngredientDetailsCommand {
    id?: number;
    unitType?: UnitType;
    productStockId?: number | undefined;
    name?: string | undefined;
    units?: number | undefined;

    constructor(data?: IUpdateCookedRecipeCalledIngredientDetailsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitType = _data["unitType"];
            this.productStockId = _data["productStockId"];
            this.name = _data["name"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): UpdateCookedRecipeCalledIngredientDetailsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCookedRecipeCalledIngredientDetailsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitType"] = this.unitType;
        data["productStockId"] = this.productStockId;
        data["name"] = this.name;
        data["units"] = this.units;
        return data;
    }
}

export interface IUpdateCookedRecipeCalledIngredientDetailsCommand {
    id?: number;
    unitType?: UnitType;
    productStockId?: number | undefined;
    name?: string | undefined;
    units?: number | undefined;
}

export class CookedRecipesVm implements ICookedRecipesVm {
    unitTypes?: UnitTypeDto[];
    cookedRecipes?: CookedRecipeDto[];
    recipesOptions?: RecipesOptionVm[];

    constructor(data?: ICookedRecipesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["unitTypes"])) {
                this.unitTypes = [] as any;
                for (let item of _data["unitTypes"])
                    this.unitTypes!.push(UnitTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["cookedRecipes"])) {
                this.cookedRecipes = [] as any;
                for (let item of _data["cookedRecipes"])
                    this.cookedRecipes!.push(CookedRecipeDto.fromJS(item));
            }
            if (Array.isArray(_data["recipesOptions"])) {
                this.recipesOptions = [] as any;
                for (let item of _data["recipesOptions"])
                    this.recipesOptions!.push(RecipesOptionVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CookedRecipesVm {
        data = typeof data === 'object' ? data : {};
        let result = new CookedRecipesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unitTypes)) {
            data["unitTypes"] = [];
            for (let item of this.unitTypes)
                data["unitTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.cookedRecipes)) {
            data["cookedRecipes"] = [];
            for (let item of this.cookedRecipes)
                data["cookedRecipes"].push(item.toJSON());
        }
        if (Array.isArray(this.recipesOptions)) {
            data["recipesOptions"] = [];
            for (let item of this.recipesOptions)
                data["recipesOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICookedRecipesVm {
    unitTypes?: UnitTypeDto[];
    cookedRecipes?: CookedRecipeDto[];
    recipesOptions?: RecipesOptionVm[];
}

export class UnitTypeDto implements IUnitTypeDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IUnitTypeDto {
    value?: number;
    name?: string | undefined;
}

export class CookedRecipeDto implements ICookedRecipeDto {
    id?: number;
    recipe?: RecipeDto;
    recipeId?: number;
    cookedRecipeCalledIngredients?: CookedRecipeCalledIngredientDetailsVm[];

    constructor(data?: ICookedRecipeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recipe = _data["recipe"] ? RecipeDto.fromJS(_data["recipe"]) : <any>undefined;
            this.recipeId = _data["recipeId"];
            if (Array.isArray(_data["cookedRecipeCalledIngredients"])) {
                this.cookedRecipeCalledIngredients = [] as any;
                for (let item of _data["cookedRecipeCalledIngredients"])
                    this.cookedRecipeCalledIngredients!.push(CookedRecipeCalledIngredientDetailsVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CookedRecipeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CookedRecipeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recipe"] = this.recipe ? this.recipe.toJSON() : <any>undefined;
        data["recipeId"] = this.recipeId;
        if (Array.isArray(this.cookedRecipeCalledIngredients)) {
            data["cookedRecipeCalledIngredients"] = [];
            for (let item of this.cookedRecipeCalledIngredients)
                data["cookedRecipeCalledIngredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICookedRecipeDto {
    id?: number;
    recipe?: RecipeDto;
    recipeId?: number;
    cookedRecipeCalledIngredients?: CookedRecipeCalledIngredientDetailsVm[];
}

export class RecipeDto implements IRecipeDto {
    id?: number;
    name?: string;
    serves?: number | undefined;
    userImport?: string | undefined;
    calledIngredients?: CalledIngredientDetailsVm[];

    constructor(data?: IRecipeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.serves = _data["serves"];
            this.userImport = _data["userImport"];
            if (Array.isArray(_data["calledIngredients"])) {
                this.calledIngredients = [] as any;
                for (let item of _data["calledIngredients"])
                    this.calledIngredients!.push(CalledIngredientDetailsVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["serves"] = this.serves;
        data["userImport"] = this.userImport;
        if (Array.isArray(this.calledIngredients)) {
            data["calledIngredients"] = [];
            for (let item of this.calledIngredients)
                data["calledIngredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRecipeDto {
    id?: number;
    name?: string;
    serves?: number | undefined;
    userImport?: string | undefined;
    calledIngredients?: CalledIngredientDetailsVm[];
}

export class RecipesOptionVm implements IRecipesOptionVm {
    value?: number;
    name?: string | undefined;

    constructor(data?: IRecipesOptionVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RecipesOptionVm {
        data = typeof data === 'object' ? data : {};
        let result = new RecipesOptionVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRecipesOptionVm {
    value?: number;
    name?: string | undefined;
}

export class CreateCookedRecipeCommand implements ICreateCookedRecipeCommand {
    recipeId?: number | undefined;

    constructor(data?: ICreateCookedRecipeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipeId = _data["recipeId"];
        }
    }

    static fromJS(data: any): CreateCookedRecipeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCookedRecipeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipeId"] = this.recipeId;
        return data;
    }
}

export interface ICreateCookedRecipeCommand {
    recipeId?: number | undefined;
}

export class GetProductsVm implements IGetProductsVm {
    unitTypes?: UnitTypeDto[];
    products?: ProductDto[];

    constructor(data?: IGetProductsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["unitTypes"])) {
                this.unitTypes = [] as any;
                for (let item of _data["unitTypes"])
                    this.unitTypes!.push(UnitTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductsVm {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unitTypes)) {
            data["unitTypes"] = [];
            for (let item of this.unitTypes)
                data["unitTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetProductsVm {
    unitTypes?: UnitTypeDto[];
    products?: ProductDto[];
}

export class CreateProductCommand implements ICreateProductCommand {
    name?: string;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateProductCommand {
    name?: string;
}

export class UpdateProductCommand implements IUpdateProductCommand {
    id?: number;
    walmartId?: number | undefined;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.walmartId = _data["walmartId"];
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["walmartId"] = this.walmartId;
        return data;
    }
}

export interface IUpdateProductCommand {
    id?: number;
    walmartId?: number | undefined;
}

export class UpdateProductNameCommand implements IUpdateProductNameCommand {
    id?: number;
    name?: string;

    constructor(data?: IUpdateProductNameCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateProductNameCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductNameCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateProductNameCommand {
    id?: number;
    name?: string;
}

export class UpdateProductUnitTypeCommand implements IUpdateProductUnitTypeCommand {
    id?: number;
    unitType?: number;

    constructor(data?: IUpdateProductUnitTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitType = _data["unitType"];
        }
    }

    static fromJS(data: any): UpdateProductUnitTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductUnitTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitType"] = this.unitType;
        return data;
    }
}

export interface IUpdateProductUnitTypeCommand {
    id?: number;
    unitType?: number;
}

export class UpdateProductSizeCommand implements IUpdateProductSizeCommand {
    id?: number;
    size?: number;

    constructor(data?: IUpdateProductSizeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): UpdateProductSizeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductSizeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["size"] = this.size;
        return data;
    }
}

export interface IUpdateProductSizeCommand {
    id?: number;
    size?: number;
}

export class GetProductStocksVm implements IGetProductStocksVm {
    unitTypes?: UnitTypeDto[];
    productStocks?: ProductStockDto[];

    constructor(data?: IGetProductStocksVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["unitTypes"])) {
                this.unitTypes = [] as any;
                for (let item of _data["unitTypes"])
                    this.unitTypes!.push(UnitTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["productStocks"])) {
                this.productStocks = [] as any;
                for (let item of _data["productStocks"])
                    this.productStocks!.push(ProductStockDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductStocksVm {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductStocksVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unitTypes)) {
            data["unitTypes"] = [];
            for (let item of this.unitTypes)
                data["unitTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.productStocks)) {
            data["productStocks"] = [];
            for (let item of this.productStocks)
                data["productStocks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetProductStocksVm {
    unitTypes?: UnitTypeDto[];
    productStocks?: ProductStockDto[];
}

export class UpdateProductStockCommand implements IUpdateProductStockCommand {
    id?: number;
    units?: number;

    constructor(data?: IUpdateProductStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): UpdateProductStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["units"] = this.units;
        return data;
    }
}

export interface IUpdateProductStockCommand {
    id?: number;
    units?: number;
}

export class ProductStockDetailsVm implements IProductStockDetailsVm {
    id?: number;
    name?: string;
    units?: number;
    productId?: number | undefined;
    product?: ProductDto;
    productSearchItems?: ProductDto[];

    constructor(data?: IProductStockDetailsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.units = _data["units"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["productSearchItems"])) {
                this.productSearchItems = [] as any;
                for (let item of _data["productSearchItems"])
                    this.productSearchItems!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductStockDetailsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStockDetailsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["units"] = this.units;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.productSearchItems)) {
            data["productSearchItems"] = [];
            for (let item of this.productSearchItems)
                data["productSearchItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductStockDetailsVm {
    id?: number;
    name?: string;
    units?: number;
    productId?: number | undefined;
    product?: ProductDto;
    productSearchItems?: ProductDto[];
}

export class UpdateProductStockDetailsCommand implements IUpdateProductStockDetailsCommand {
    id?: number;
    productId?: number;
    units?: number;

    constructor(data?: IUpdateProductStockDetailsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): UpdateProductStockDetailsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductStockDetailsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["units"] = this.units;
        return data;
    }
}

export interface IUpdateProductStockDetailsCommand {
    id?: number;
    productId?: number;
    units?: number;
}

export class CreateProductStockCommand implements ICreateProductStockCommand {
    name?: string;

    constructor(data?: ICreateProductStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateProductStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateProductStockCommand {
    name?: string;
}

export class RecipesVm implements IRecipesVm {
    unitTypes?: UnitTypeDto[];
    recipes?: RecipeDto[];

    constructor(data?: IRecipesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["unitTypes"])) {
                this.unitTypes = [] as any;
                for (let item of _data["unitTypes"])
                    this.unitTypes!.push(UnitTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["recipes"])) {
                this.recipes = [] as any;
                for (let item of _data["recipes"])
                    this.recipes!.push(RecipeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipesVm {
        data = typeof data === 'object' ? data : {};
        let result = new RecipesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unitTypes)) {
            data["unitTypes"] = [];
            for (let item of this.unitTypes)
                data["unitTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.recipes)) {
            data["recipes"] = [];
            for (let item of this.recipes)
                data["recipes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRecipesVm {
    unitTypes?: UnitTypeDto[];
    recipes?: RecipeDto[];
}

export class CreateRecipeCommand implements ICreateRecipeCommand {
    name?: string;
    serves?: number | undefined;
    userImport?: string | undefined;

    constructor(data?: ICreateRecipeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.serves = _data["serves"];
            this.userImport = _data["userImport"];
        }
    }

    static fromJS(data: any): CreateRecipeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecipeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["serves"] = this.serves;
        data["userImport"] = this.userImport;
        return data;
    }
}

export interface ICreateRecipeCommand {
    name?: string;
    serves?: number | undefined;
    userImport?: string | undefined;
}

export class UpdateRecipeNameCommand implements IUpdateRecipeNameCommand {
    id?: number;
    name?: string;

    constructor(data?: IUpdateRecipeNameCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateRecipeNameCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRecipeNameCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateRecipeNameCommand {
    id?: number;
    name?: string;
}

export class UpdateRecipeServesCommand implements IUpdateRecipeServesCommand {
    id?: number;
    serves?: number | undefined;

    constructor(data?: IUpdateRecipeServesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serves = _data["serves"];
        }
    }

    static fromJS(data: any): UpdateRecipeServesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRecipeServesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serves"] = this.serves;
        return data;
    }
}

export interface IUpdateRecipeServesCommand {
    id?: number;
    serves?: number | undefined;
}

export class PaginatedListOfTodoItemBriefDto implements IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: ITodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): TodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[];
    lists?: TodoListDto[];

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[];
    lists?: TodoListDto[];
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["colour"] = this.colour;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}